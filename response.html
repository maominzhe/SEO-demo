<div class="blogpost wysiwyg">
  <p>
    <img
      alt="Outfit Page"
      loading="lazy"
      sizes="(max-width: 660px) 100vw, 660px"
      src="https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=1320#previewimage"
      srcset="
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=360#previewimage   360w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=480#previewimage   480w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=660#previewimage   660w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=960#previewimage   960w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-outfit-page.png?imwidth=1320#previewimage 1320w
      "
    />
  </p>
  <p>
    Welcome back to our web platform blog series! It's been a while since we
    <a
      href="https://engineering.zalando.com/posts/2021/09/micro-frontends-part2.html"
      >last talked about</a
    >
    our approach to large-scale front-end development at Zalando. We are excited
    now to reconnect and share with you some substantial enhancements we've made
    to the streaming and rendering architecture of our Rendering Engine
    framework.
  </p>
  <p>
    The first post of this new series will recap how Rendering Engine works, its
    relationship with Concurrent React, and our journey with it including design
    and implementation challenges as well as successes gained so far. <br />
    Additionally, it covers the main hydration mismatch errors we faced during
    this upgrade, our solutions and recommendations for avoiding them, and some
    extra tips and tricks for debugging this type of issue.
  </p>
  <h2>Intro</h2>
  <p>
    "Rendering Engine" is the web framework that is maintained by and currently
    used in Zalando to render the
    <a href="https://en.zalando.de/">Fashion Store website</a>, and is designed
    for building any web application with similar needs.
  </p>
  <p>
    You might know Rendering Engine (<strong>RE</strong>) from our previous blog
    posts about Micro Frontends at Zalando and our journey through them from
    Project Mosaic with its
    <a
      href="https://engineering.zalando.com/posts/2018/12/front-end-micro-services.html"
      >fragments</a
    >
    and <a href="https://github.com/zalando/tailor">Tailor</a>, to
    <a
      href="https://engineering.zalando.com/posts/2021/03/micro-frontends-part1.html"
      >Interface Framework</a
    >
    (<a
      href="https://engineering.zalando.com/posts/2021/09/micro-frontends-part2.html"
      >part 2</a
    >).
  </p>
  <p>
    In a nutshell, <strong>RE</strong> is a web framework best suited for
    creating a website that:
  </p>
  <ul>
    <li>Uses React to render the UI</li>
    <li>
      Inherently implements universal rendering (server side / client side) with
      high emphasis on server rendering and page load performance
    </li>
    <li>
      Its page content, layout and UI steering is highly driven by backend in a
      nestable approach
    </li>
    <li>
      The backend can be a recommendation engine, a CMS-like system able to
      define the shape and content of pages, or any other similar system.
    </li>
  </ul>
  <p>
    The building blocks of RE's language for defining what to render, are
    <strong>Entities</strong>. Each <strong>Entity</strong> is a block of
    content that from a business-logic perspective has a specific identity, and
    can have other Entities nested inside. For example in the context of a
    fashion store, an Entity could be a Product, a Collection of products, an
    Outfit, etc. Which when organized in tree-like structures, can be used to
    define full layout and contents of pages. Defining each Entity from the
    backend is done through specifying a <strong><em>type</em></strong
    >, <strong><em>id</em></strong
    >, and optional extra data in the form of <strong><em>hints</em></strong
    >. We'll skip how RE handles defining layouts from the backend for the time
    being.
  </p>
  <p>
    So by considering Entities to be responsible for describing "<em
      >what to render</em
    >" (by the backend), then specifying "<em>how to render</em>" is the
    responsibility of what we call a <strong>Renderer</strong> (by the client).
    <br />
    Each <strong>Renderer</strong> is a self-contained TypeScript module powered
    by multiple RE features provided during server- and client-side rendering.
    Each Renderer is responsible to render a specific type of Entity, while each
    Entity-type can be represented by multiple Renderers depending on the extra
    hints data.
  </p>
  <p>
    This assignment mapping is defined via something called
    <strong>Rendering Rules</strong>. These configurations are passed to RE,
    which include "selectors" for matching the incoming Entity definitions from
    backend, and support nested and per-page rules.
  </p>
  <p>
    There are a handful of other features built into this framework including
    monitoring, experimentation, tracking, a different rendering output for
    server driven mobile apps, etc. but for now this introduction should do.
  </p>
  <h2>React 18's Concurrent Rendering</h2>
  <h4 style="opacity: 0.7">(and how it fits Rendering Engine like a glove)</h4>
  <p>
    Performance has always been one of the key focus areas of Rendering Engine
    from its beginnings. Aside from being built with performance in mind and
    going through many micro improvements over the years, it also comes with
    some performance features built inside, including but not limited to
    streaming, lazy-loading, partial streaming and partial hydration (yes,
    almost the same concept as in Concurrent React!).
  </p>
  <p>
    Although these performance related features have proven to be very important
    in the success of the Fashion Store website, their code's maintenance,
    improvements and required education as well as knowledge sharing come with a
    cost.
  </p>
  <p>
    But more importantly, we anticipated having React's built-in support for
    these features would most probably bring even more performance boosts to the
    table.
  </p>
  <p>
    Additionally, React's concurrent rendering APIs seamlessly integrate with
    the architecture of RE because its Renderers serve as ideal candidates for
    being encapsulated within a Suspense boundary. This enables them to function
    as individual blocks that can be server-rendered, streamed, hydrated, and
    client-rendered "concurrently". Especially since many of them have already
    been using Rendering Engine's own partial hydration/streaming features!
  </p>
  <p>
    As a result, we have been very excited about the concurrent React 18 for
    quite a while and as soon as the opportunity arrived, we started the
    migration and refactoring of Rendering Engine's core functionalities to use
    the concurrent features.
  </p>
  <p>
    Needless to say, this migration task has also had its challenges and costs!
    So now that we have finished some important milestones and are close to
    completion, we thought it is a good chance to start sharing our challenges,
    successes and learnings with you.
  </p>
  <h2>Design challenges with Concurrent Rendering</h2>
  <p>
    Rendering Engine at its core includes logic for handling the resolution of
    server's specified Entity definitions or layout into the corresponding
    Renderers, fetching their data as well as handling all the other
    aforementioned features like experimentation, tracking, etc. And only after
    that, it hands over the UI rendering responsibilities to React. <br />
    These happen gradually (and if needed, recursively) in a way that makes sure
    that Renderers remain independent while getting their data and
    rendering/streaming their final html, which makes way for performance gains.
  </p>
  <p>
    So initially, with React 18 we thought of moving as much of this logic as
    possible (from data fetching to experimentation, tracking, etc.) to the
    React concurrent APIs such as Suspense and <code>useTransition</code>,
    through custom hooks - which is often referred to as the
    "Render-As-You-Fetch pattern. With the aim of reducing complexity and
    required effort among other things.
  </p>
  <p>
    But after a trial phase and implementing a proof of concept, we faced some
    issues, the main ones being:
  </p>
  <ul>
    <li>
      In cases where keeping the correct order of the content during
      streaming/hydration is important, the closest available solution would be
      to use the <code>SuspenseList</code> API. But it still seems to be
      <a
        href="https://github.com/facebook/react/issues/22771#issuecomment-969451702"
        >experimental, with some limitations</a
      >.
    </li>
    <li>
      The
      <a href="https://github.com/facebook/react/issues/25082"
        ><code>useTransition</code> API not considering nested suspense
        boundaries</a
      >, causing bad UX in some scenarios.
    </li>
    <li>
      By utilizing hooks to initiate requests or other async operations, the
      timing of fetch operations becomes coupled with the order of rendering,
      which may not be optimal for performance.
    </li>
    <li>
      Progressive hydration and streaming, necessitate the availability of all
      the data required for client-side rendering as early as possible. This
      implies that, in addition to the HTML generated by components, it is
      crucial to stream their data to prevent redundant requests from being made
      by the client.
      <ul>
        <li>
          During the trial phase, the streaming and caching layer to support
          this issue wasn't yet handled by React. And as of now, the
          <a href="https://github.com/facebook/react/pull/25502"
            >latest supporting feature</a
          >
          is still not final.
        </li>
      </ul>
    </li>
  </ul>
  <h3>Chosen technical design</h3>
  <p>
    Due to the limitations mentioned above, we finally decided to go with a
    mixed solution.
  </p>
  <p>
    In this approach, the concurrent streaming, hydration, rendering and
    basically all the Concurrent benefits are still achieved via fully utilizing
    React: by wrapping every Renderer in a Suspense boundary, and handling
    changes through concurrent APIs. <br />
    But at the same time, we created an "Application State" layer which
    encapsulates the main logic and Renderers data outside of React
    components/hooks in a central place, which dictates to the Suspense
    boundaries their state.
  </p>
  <p>
    This way, the full power of orchestrating when to suspend a component
    (Renderer) depending on its place in the tree, handling the order of the
    suspended components, and deciding how to manage a transition considering
    the nested Suspense boundaries, would all be available and customizable in
    this Application State layer. <br /><em
      >We will share the details of the technical solution for ordered
      streaming/hydration in another post</em
    >.
  </p>
  <p>
    In other words, everytime RE finds the matching Renderer and resolves all
    its corresponding data for an Entity definition (through "resolveEntity"
    step), the output will be written to the Application State layer. In the
    meantime React is rendering the Renderer components which are wrapped with
    Suspense. <br />
    To access data from the Application State, the suspendable Renderers use the
    "Connector hook". <br />
    The Connector hook reads from the application state which either returns the
    data that was asked for, or creates a promise that will be resolved once the
    data has been written. The promise is then used to suspend the component and
    React will automatically re-render once the Promise has been resolved.
    <br /><em
      >Imagine Redux's <code>useSelector</code> hook, but instead of immediately
      returning selected data you get a Promise that only resolves once a
      reducer has made the data available.</em
    >
  </p>
  <p>
    <img
      alt="Rendering Engine architecture using Concurrent React"
      loading="lazy"
      sizes="(max-width: 660px) 100vw, 660px"
      src="https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=1320"
      srcset="
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=360   360w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=480   480w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=660   660w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=960   960w,
        https://img01.ztat.net/engineering-blog/posts/2023/07/images/rengine-concurrent-react.jpg?imwidth=1320 1320w
      "
    />
  </p>
  <h2>Benefits gained from Concurrent Rendering</h2>
  <p>
    As we are still going through the changes and final steps of the
    full-fledged concurrent mode described above, the full benefits of it are
    yet to be observed.
  </p>
  <p>
    Till date, we achieved some performance improvements by mainly using the new
    streaming and hydration root APIs.
  </p>
  <h3>
    Performance improvements from <code>renderToPipeableStream</code> and
    <code>hydrateRoot</code> APIs
  </h3>
  <p>
    As one of the milestones, after pure version upgrade and handling breaking
    changes, we solely changed RE's internal streaming and hydration code to use
    the new React 18 APIs instead. i.e.
    <code>renderToPipeableStream</code> instead of
    <code>renderToNodeStream</code>, and <code>hydrateRoot</code> instead of
    <code>hydrate</code>. <br />
    We rolled out this change through an A/B test covering all pages of our
    e-commerce website, and in the end we observed these mild performance (and
    business metric) improvements:
  </p>
  <p><strong>Overall</strong></p>
  <ul>
    <li>
      <a href="https://web.dev/inp/">INP</a>:
      <span style="color: #61bd6d"><strong>-5.69%</strong></span>
    </li>
    <li>
      <a href="https://web.dev/fid/">FID</a>:
      <span style="color: #61bd6d"><strong>-8.81%</strong></span>
    </li>
    <li>
      <a href="https://web.dev/lcp/">LCP</a>:
      <span style="color: #61bd6d"><strong>-2.43%</strong></span>
    </li>
    <li>
      <a href="https://web.dev/fcp/">FCP</a>:
      <span style="color: #61bd6d"><strong>-0.23%</strong></span>
    </li>
    <li>
      <strong>Bounce rate</strong>:
      <span style="color: #61bd6d"><strong>-0.24%</strong></span>
    </li>
  </ul>
  <p><strong>Per page:</strong> (some of the frequently visited pages)</p>
  <table>
    <thead>
      <tr>
        <th style="text-align: center"><strong>Metric</strong></th>
        <th style="text-align: center"><strong>Home page</strong></th>
        <th style="text-align: center">
          <strong>Catalog page</strong><br /><em
            >(list of products and search)</em
          >
        </th>
        <th style="text-align: center">
          <strong>Product Details page</strong>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: center"><strong>INP</strong></td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-2.92%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-6.76%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-6.09%</strong></span>
        </td>
      </tr>
      <tr>
        <td style="text-align: center"><strong>FID</strong></td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-2.98%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-17.11%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-6.06%</strong></span>
        </td>
      </tr>
      <tr>
        <td style="text-align: center"><strong>Exit Rate</strong></td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-0.43%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-0.06%</strong></span>
        </td>
        <td style="text-align: center">
          <span style="color: #61bd6d"><strong>-0.06%</strong></span>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    Needless to say, this shows great promise, and we are now even more excited
    about the results of the next steps.
  </p>
  <h2>Technical challenges: Rise of the Hydration Mismatch errors!</h2>
  <p>
    As also stated in
    <a
      href="https://github.com/reactjs/rfcs/blob/ba9bd5744cb922184ec9390515910cd104a30c6e/text/0215-server-errors-in-react-18.md#hydration-mismatches"
      >some documentations around React 18</a
    >, because the new React APIs are way more sensitive towards existing
    hydration mismatch issues, after the migration to the new streaming and
    hydration APIs, we started receiving a lot more hydration error logs (via
    Sentry) for Zalando Fashion Store. <br />
    So during this migration, we've been finding and fixing these issues to
    prevent negative user impact as much as possible. And after fixing dozens of
    different types of issues deep inside hundreds of Renderers, we were able to
    considerably reduce the number of the hydration mismatch errors occuring in
    the wild. That being said, there are still some more errors to fix which are
    harder to reproduce and find due to the dynamic nature of the page content
    in Fashion Store. <br />
    Nevertheless, below you can find the most common issues we found so far, and
    how we were able to fix them.
  </p>
  <p>
    After that, we also briefly share some tips and tricks about the debugging
    process. Because - as you may also know if you have faced these errors in
    your projects - debugging them is not always a straightforward task, and to
    be honest, React's error logs (especially coming from the production
    environment) aren't very helpful!
  </p>
  <h3>Main types of issues we faced, and suggested solutions</h3>
  <p>
    Before going through details of each type, in some cases we realized that
    based on product requirements, one might actually not need to render some
    content on SSR (Server Side Rendering) and only the CSR (Client Side
    Rendering) would be enough. <br />
    Hence the obvious fix might be to just skip rendering on SSR and only show
    the content once the app is mounted on the user's browser.
  </p>
  <p>
    To do that, we can rely on React hooks and lifecycle methods to ensure the
    app/component has been mounted on the browser. For example:
  </p>
  <p><strong>Instead of</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">dataThatDiffersBetweenClientAndServer</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">props</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">dataThatDiffersBetweenClientAndServer</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p><strong>Do</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="c1">//...</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isMounted</span><span class="p">,</span><span class="w"> </span><span class="nx">setIsMounted</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="nx">React</span><span class="p">.</span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setIsMounted</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">dataThatDiffersBetweenClientAndServer</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">props</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">isMounted</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">dataThatDiffersBetweenClientAndServer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s2">"some fallback"</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="kc">null</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p>
    There are similar cases where due to the basic differences between the SSR
    and the CSR, like some data only being available on client side, one might
    need to render different content or elements on the two. For example, based
    on the exact specifications of the user's device, you want to display an app
    download banner.
  </p>
  <p>
    For these scenarios, the suggestion would again be to simply wait until the
    initial hydration phase is finished on the client side, and then render the
    different content.
  </p>
  <p>
    <strong>Note</strong>: in such cases, be mindful of layout shifts that can
    happen as a result of some element popping into the view.
  </p>
  <p>With that out of the way, let's dive into the list of issues.</p>
  <h4>1. Timers</h4>
  <p>
    This is a common and somewhat expected source of hydration mismatch issues
    simply because if you're calculating and rendering the distance between two
    specific points in time (usually from past/future to now), it will result in
    slightly different values when calculated on SSR compared to a few moments
    later on CSR.
  </p>
  <p>
    As also mentioned in
    <a
      href="https://react.dev/reference/react-dom/client/hydrateRoot#suppressing-unavoidable-hydration-mismatch-errors"
      >React docs</a
    >, in such cases where the mismatch is unavoidable, the suggestion is to
    simply tell React that the difference is expected and that React should
    ignore the mismatch during hydration. The way to do this is by passing the
    prop <code>suppressHydrationWarning={true}</code> to the element that
    contains such a mismatch. Keep in mind that this prop only works one level
    deep, so you have to pass it to the closest element wrapping the mismatching
    text. For example:
  </p>
  <p><strong>Instead of</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">timeDistance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">targetDate</span><span class="p">.</span><span class="nx">getTime</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">timeDistance</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p><strong>Do</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">timeDistance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">targetDate</span><span class="p">.</span><span class="nx">getTime</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="w"> </span><span class="nx">suppressHydrationWarning</span><span class="o">=</span><span class="p">{</span><span class="kc">true</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">timeDistance</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <h4>2. Localization of dates and different time-zones</h4>
  <p>
    Converting date values from raw formats (e.g. ISO 8601
    <code>2023-01-01T20:00:00.000Z</code>) to human-readable strings can be a
    tricky cause of hydration mismatch errors. <br />
    Because if the timezone used for conversion is different between the server
    and client, the resulting values can be different as well.
  </p>
  <p>
    So for example if the timezone is not specified while using the localization
    APIs (e.g. <code>Intl.DateTimeFormat</code> or
    <code>Date.prototype.toLocaleString</code>), then the host timezone will be
    used and if the SSR server has a different timezone than the user, it will
    lead to different localized date values in the end.
  </p>
  <p>
    It's hard to decide what the best solution is in these cases especially
    because as of now it is not possible to know the exact local timezone of the
    user on SSR based on http headers (in the initial request). <br />
    On top of that, the question of which timezone to use for displaying dates
    is ultimately a product decision.
  </p>
  <p>
    But if a specific universal timezone is approved and provided (for example
    the website's domain's matching timezone), then specifying that universal
    timezone to the conversion APIs on both the client and server code can fix
    this issue. Meaning:
  </p>
  <p><strong>Instead of</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">someDate</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">(</span><span class="nx">locale</span><span class="p">)}</span>
<span class="w">      </span><span class="p">{</span><span class="ow">new</span><span class="w"> </span><span class="nb">Intl</span><span class="p">.</span><span class="nx">DateTimeFormat</span><span class="p">(</span><span class="nx">locale</span><span class="p">).</span><span class="nx">format</span><span class="p">(</span><span class="nx">someDate</span><span class="p">)}</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p><strong>Do</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">someDate</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">(</span><span class="nx">locale</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">timeZone</span><span class="o">:</span><span class="w"> </span><span class="nx">universalTimezone</span><span class="w"> </span><span class="p">})}</span>
<span class="w">      </span><span class="p">{</span><span class="ow">new</span><span class="w"> </span><span class="nb">Intl</span><span class="p">.</span><span class="nx">DateTimeFormat</span><span class="p">(</span><span class="nx">locale</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">timeZone</span><span class="o">:</span><span class="w"> </span><span class="nx">universalTimezone</span><span class="w"> </span><span class="p">}).</span><span class="nx">format</span><span class="p">(</span><span class="nx">someDate</span><span class="p">)}</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p>
    That being said, depending on the situation and product requirements, an
    alternative approach would be to just move the conversion to the backend so
    that the client simply receives dates in the localized format - which has
    passed through timezone transformation (and localisation).
  </p>
  <h4>3. Localization of numbers</h4>
  <h5 style="opacity: 0.7">(and a Safari bug for "de-AT" locale!)</h5>
  <p>
    Similar to converting dates and importance of timezones, when converting raw
    numbers to localized human-readable strings (e.g. <code>12345</code> to
    <code>"12,345"</code>) if the locale is not specified, then the host's
    locale will be used and it can lead to different results. So it's important
    to always pass a universal locale to these APIs which is consistent during
    server and client rendering:
  </p>
  <p><strong>Instead of</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">someNumber</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">()}</span>
<span class="w">      </span><span class="p">{</span><span class="ow">new</span><span class="w"> </span><span class="nb">Intl</span><span class="p">.</span><span class="nx">DateTimeFormat</span><span class="p">().</span><span class="nx">format</span><span class="p">(</span><span class="nx">someNumber</span><span class="p">)}</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p><strong>Do</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">someNumber</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">(</span><span class="nx">universalLocale</span><span class="p">)}</span>
<span class="w">      </span><span class="p">{</span><span class="ow">new</span><span class="w"> </span><span class="nb">Intl</span><span class="p">.</span><span class="nx">DateTimeFormat</span><span class="p">(</span><span class="nx">universalLocale</span><span class="p">).</span><span class="nx">format</span><span class="p">(</span><span class="nx">someNumber</span><span class="p">)}</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p>
    But in very specific cases, we observed that the localisation APIs act
    differently between SSR and CSR, which again lead to generating different
    values, thus hydration mismatches!
  </p>
  <p>
    We particularly encountered this issue with the Safari browser where for the
    de-AT locale, the localisation APIs (like <code>Intl.NumberFormat</code> or
    <code>tolocalestring</code>) generate values like <code>"2.345"</code> but
    other browsers including Chrome and Firefox as well as Node.js generate
    values like <code>"2 345"</code> for the same locale!
  </p>
  <p>
    So an alternative approach in these cases would be to receive the final
    localized values from the backend and show that to the user without needing
    any more modifications, thus eliminating the mismatches.
  </p>
  <h4>4. Invalid HTML nesting</h4>
  <p>
    This issue might be a new cause of hydration mismatch in React 18, which
    happens as a result of incorrect HTML like nesting a
    <code>&lt;div&gt;</code> inside a <code>&lt;p&gt;</code> or
    <code>&lt;button&gt;</code> inside <code>&lt;button&gt;</code>. We couldn't
    find clear documentation from React explaining why HTML validity issues lead
    to hydration mismatch errors (aside from community discussions
    <a href="https://github.com/facebook/react/issues/24519">like here</a>). But
    regardless, to avoid them, adding markup validation steps (like
    <a href="https://github.com/MananTank/eslint-plugin-validate-jsx-nesting"
      >this eslint plugin</a
    >) could be helpful.
  </p>
  <p>
    Either Way, in such cases the obvious goal is to use semantically correct
    HTML elements while nesting. For example:
  </p>
  <p><strong>Instead of</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Some</span><span class="w"> </span><span class="nx">text</span><span class="o">&lt;</span><span class="err">/div&gt;&lt;/p&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="nx">button</span><span class="o">&gt;&lt;</span><span class="nx">button</span><span class="o">&gt;</span><span class="nx">Button</span><span class="w"> </span><span class="nx">text</span><span class="o">&lt;</span><span class="err">/button&gt;&lt;/button&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <p><strong>Do</strong></p>
  <div class="highlight">
    <pre><span></span><code><span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Some</span><span class="w"> </span><span class="nx">text</span><span class="o">&lt;</span><span class="err">/span&gt;&lt;/p&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="nx">button</span><span class="o">&gt;&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Button</span><span class="w"> </span><span class="nx">text</span><span class="o">&lt;</span><span class="err">/span&gt;&lt;/button&gt;</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
</code></pre>
  </div>
  <h3>Some debugging tips &amp; tricks</h3>
  <p>
    Soon after receiving the new hydration mismatch logs in our error tracking
    system (Sentry), it was clear that the most important first step in
    debugging them is whether we can reproduce them or not! <br />
    Because due to the nature of the React hydration errors in its production
    bundle, there is not much detail you can get from the error messages in
    Sentry. Although including the
    <a
      href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactInternalTypes.js#L254"
      ><code>componentStack</code></a
    >
    from the <code>hydrateRoot</code>‘s <code>onRecoverableError</code> callback
    in the logs comes in quite handy, (especially after cleaning the stack a bit
    to make it more readable) but due to code minification and uglifying in
    production bundle of your application, you will still have to carry out
    complicated tasks and use the provided line/column numbers to find the
    closest components with the help of sourcemaps.
  </p>
  <p>
    On top of that, if a website has dynamic content served to each user like
    Zalando Fashion Store, it may be even harder to reproduce the exact page
    (with the same content) that was receiving a specific error.
  </p>
  <p>
    Another issue we encountered was that the
    <code>onRecoverableError</code> callback is usually called multiple times by
    React for a single hydration mismatch problem, both polluting our Sentry
    logs as well as making the debugging process harder. <br />
    This seems to be due to
    <a
      href="https://github.com/facebook/react/blob/fc929cf4ead35f99c4e9612a95e8a0bb8f5df25d/packages/react-reconciler/src/ReactFiberHydrationContext.js#L447"
      >the way hydration phase works</a
    >, in which React compares a list of available server rendered DOM nodes
    with a list of client rendered React elements ("fibers") and tries to match
    them together and basically hydrate the nodes. And when matching and
    hydration fails for a specific node instance and errors are logged, it
    <a
      href="https://github.com/facebook/react/blob/fc929cf4ead35f99c4e9612a95e8a0bb8f5df25d/packages/react-reconciler/src/ReactFiberHydrationContext.js#L474"
      >tries to hydrate the next one</a
    >. What we observed here was that (at least in some cases) because of the
    previous mismatching node/fiber, the order of the lists becomes broken, and
    that leads to all the next ones failing as well. And that means a lot of
    other hydration mismatch error logs which aren't necessarily correct. <br />
    To mitigate this in the production environment, we modified our error
    tracking code to only send the first hydration error log to Sentry. We also
    found this to be very helpful to keep in mind during development debugging.
  </p>
  <p>
    But in case reproducing the error locally is possible, then we found these
    steps to be helpful:
  </p>
  <ul>
    <li>
      Work on the first error log, and after it's fixed, check if any other one
      remains.
    </li>
    <li>
      Based on the log and the <code>componentStack</code>, find the closest
      component(s) causing the issue.
    </li>
    <li>
      In some cases the cause of the issue is obvious in the specified
      component's source code - for example the issue number 4 mentioned above
      (Invalid HTML nesting).
      <ul>
        <li>
          With HTML nesting issues, the log usually contains the text
          <code>validateDOMNesting(...)</code>.
        </li>
      </ul>
    </li>
    <li>
      In other cases where the cause is not very obvious, what we found helpful
      was to check the React dev bundle
      (<code>react-dom/umd/react-dom.development.js</code>) and put debuggers on
      places which log the hydration errors (usually the
      <code>checkForUnmatchedText</code> or
      <code>throwOnHydrationMismatch</code> functions).
      <ul>
        <li>
          Then by loading the page, try to find out what is the exact React
          fiber that causes the issue, and based on that find the
          component/element. Don't be afraid to go higher in the stack and use
          more debuggers!
        </li>
        <li>
          In some cases we realized that the fiber is the same element that
          caused the issue, but in others, it's more confusing as the fiber is
          something that was rendered <strong>after</strong> a mismatching
          (usually missing) node instance that was the actual cause of the
          issue.
        </li>
        <li>
          Here it also helps to check different variables like
          <code>fiber</code>, <code>nextInstance</code>, <code>current</code>,
          etc. including their received props.
        </li>
      </ul>
    </li>
  </ul>
  <h2>Conclusion</h2>
  <p>
    The migration to React 18 and its concurrent features was of extra
    importance for our Rendering Engine framework due to its unique
    architecture. And despite the challenges, the results have been promising so
    far, especially since we observed improvements over Fashion Store website’s
    Core Web Vitals and bounce rate.
  </p>
  <p>
    Additionally, the upgrade shined a light on the hidden hydration mismatch
    issues scattered in different components, which led us to not only fix many
    of them, but also collect and internally document them along with
    recommendations and debugging tips for further reference.
  </p>
  <h2>Next Steps</h2>
  <p>
    We are planning to share more detailed posts in the future about the
    architecture and technical specs of Rendering Engine - especially in light
    of the Concurrent features. <br />
    Additionally, we aim to share the effects of the new features and the final
    architecture on Zalando Fashion Store's performance.
  </p>
  <p>
    Next up, we're excited to start using React Server Components which have
    shown great promise so far. Stay tuned!
  </p>
</div>
